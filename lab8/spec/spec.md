# Lab 8: Um Processador Monociclo Completo

<p align="center">Prof. Jo√£o Carlos Bittencourt</p>
<p align="center">Monitor: √âverton Gomes dos Santos</p>
<p align="center">Centro de Ci√™ncias Exatas e Tecnol√≥gicas</p>
<p align="center">Universidade Federal do Rec√¥ncavo da Bahia, Cruz das Almas</p>

## Introdu√ß√£o

Ao longo deste roteiro de laborat√≥rio voc√™ ir√° aprender a:

- Integrar ALU, registradores, etc., para formar um caminho de dados completo.
- Projetar a unidade de controle de um processador MIPS.
- Integrar a unidade de controle ao caminho de dados.
- Integrar unidades de mem√≥ria a um processador.
- Codificar um conjunto de instru√ß√µes.
- Mais pr√°ticas com rotinas de teste para verifica√ß√£o de um processador.

## Revise os Slides de Aula: Processador RISC Single-cycle

Estude os slides de aula cuidadosamente, e revise os Cap√≠tulos 7.1--7.3 do [livro do David e Sarah Harris](https://www.google.com.br/books/edition/Digital_Design_and_Computer_Architecture/SksiEAAAQBAJ?hl=pt-BR&gbpv=0). Revise tamb√©m o [folheto verde](https://gcet231.github.io/#/recursos/MIPS_Green_Sheet.pdf) do livro Patterson & Hennessy contendo o conjunto de instru√ß√µes do processador MIPS.

> üéØ Uma vers√£o PDF deste folheto pode ser acessada [aqui](https://gcet231.github.io/#/recursos/MIPS_Green_Sheet.pdf).

Apesar de haverem diferen√ßas entre os livros de autoria de Patterson & Hennessy e o livro texto Harris Harris, n√≥s utilizaremos o primeiro. Faremos isso por que o [simulador MARS](http://courses.missouristate.edu/kenvollmar/mars/), que voc√™ utilizar√° para construir seu c√≥digo assembly, segue o livro do Patterson & Hennessy.

Estude especialmente os Slides 33--38 para identificar as decis√µes de projeto espec√≠ficas para vers√£o do processador utilizada em nosso laborat√≥rio:

- **Exce√ß√µes:** Nossa vers√£o do MIPS n√£o possui suporte a exce√ß√µes.
- **Reset:** Nosso processador possui suporte a sinal de reset. Mais especificamente, se a entrada `reset` for acionada, o contador de programas (_program counter_) √© reiniciado para o endere√ßo `0x0040_0000`. Este endere√ßo foi escolhido tendo em vista compatibiliz√°-lo com o assembler MARS. Desta forma, o registrador PC, presente no _data path_, deve ser inicializado neste endere√ßo, e reiniciado sempre que o `reset` for acionado.
- **Enable:** Para auxiliar no processo de depura√ß√£o, n√≥s vamos incorporar um sinal de entrada `enable`. Quando ativo, o processador executa normalmente as instru√ß√µes. Entretanto, quando `enable == 0`, o processador "congela". Esse procedimento √© realizado desativando a escrita nos seguintes componentes: _program counter_, _register file_ e _mem√≥ria de dados_. Essa modifica√ß√£o permitir√° executar nossos programas passo-a-passo, auxiliando assim no processo de depura√ß√£o.

## A Unidade de Controle

Para preparar o projeto de um processador MIPS, n√≥s iniciaremos com o desenvolvimento da unidade de controle. A seguir s√£o apresentados dois diagramas no nosso processador MIPS _single-cycle_, primeiro com uma vis√£o de alto n√≠vel, e em seguida uma vers√£o mais detalhada.

![Caminho de Dados do Processador MIPS](./Datapath.png)

A seguir apresentamos uma vis√£o mais detalhada.

![Caminho de Dados do Processador MIPS detalhado](./MIPS2.png)

Primeiro vamos desenvolver a unidade de controle. Ela deve dar suporte a TODAS as instru√ß√µes apresentadas a seguir:

- Load (`lw`) e store (`sw`)
- Instru√ß√µes do Tipo-I: `addi`, `addiu`, `slti`, `sltiu`, `ori`, `lui`, `andi`, `xori`}
  - Diferente do que voc√™ possa ter aprendido, `addiu`, na verdade, n√£o realiza uma soma sem sinal (_unsigned_). Na verdade, ela estende o sinal do imediato (replica o bit mais significativo at√© completar os 32 bits). A √∫nica diferen√ßa entre `addi` e `addiu` √© que a instru√ß√£o `addiu` n√£o causa uma exce√ß√£o na ocorr√™ncia de um _overflow_, enquanto que a `addi` sim. Como n√£o estamos implementando exce√ß√µes no nosso processador, `addiu` e `addi` s√£o id√™nticas para nossos prop√≥sitos.
  - Tamb√©m diferente do que voc√™ possa ter aprendido, a instru√ß√£o `sltiu`, na verdade, tamb√©m estende o sinal do imediato, _mas realiza uma compara√ß√£o sem sinal_. Ou seja, a opera√ß√£o definida por `ALUFN` √© `LTU`.
  - Note ainda que a instru√ß√£o `ori` deve estender zero a partir do imediato (completar a palavra com zeros), por se tratar de uma opera√ß√£o l√≥gica! Finalmente, a extens√£o do sinal para a instru√ß√£o `lui` √© um _don't-care_, uma vez que o imediato de 16-bits √© posicionado na parte mais significativa do registrador.
  - Os valores de `pcsel` depender√£o da _flag_ de zero (`Z`). Esta _flag_ deve indicar se o resultado da opera√ß√£o aritm√©tica √© igual ou diferente de zero.
- Instru√ß√µes do Tipo-R: `add, addu, sub, and, or, xor, nor, slt, sltu, sll, sllv, srl` e `sra`
  - Para nossos prop√≥sitos, a instru√ß√£o `addu` √© _semelhante_ √† instru√ß√£o `add`. A diferen√ßa est√° apenas na foma como elas lidam com o _overflow_ -- situa√ß√£o que ser√° ignorada no nosso projeto. A raz√£o para darmos suporte √† instru√ß√£o `addu` √© que o assembler MARS geralmente introduz automaticamente instru√ß√µes `addu` no nosso c√≥digo, especialmente para a faixa de endere√ßos de mem√≥ria que n√≥s estamos usando.
- Instru√ß√µes do Tipo-J e Saltos (_branches_ - Tipo-I): `beq, bne, j, jal` e `jr`.

Estude os slides de aula sobre o processador RISC single-cycle (incluindo os Slides 33--38). Em seguida preencha a Tabela abaixo com os valores de todos os sinais de controle para as 28 instru√ß√µes RISC listadas aqui. Se o valor de um sinal de controle n√£o importa para uma dada instru√ß√£o, voc√™ poder√° usar o s√≠mbolo de _don't care_ (`1'bx`, `2'bx`, etc., dependendo da quantidade de bits).

> üíÅ A partir dos valores da Tabela, complete o c√≥digo Verilog da unidade de controle no arquivo `controler.sv`, disponibilizado junto com os arquivos de laborat√≥rio.

Utilize o _test bench_ fornecido para simular e validar o seu projeto. Assim como nos roteiros anteriores, esse _test bench_ √© auto-verific√°vel, de modo que, se algum erro for identificado, ele ser√° sinalizado no _waveform_ do simulador.

> ‚ö†Ô∏è Certifique-se de utilizar os mesmos nomes, presentes no teste, para as entradas e sa√≠das do _top-level_.

|  Type  | Instr | werf | wdsel | wasel | asel | bsel | sext | wr  | alufn |   pcsel    |
| :----: | :---: | :--: | :---: | :---: | :--: | :--: | :--: | :-: | :---: | :--------: |
| I-Type |  LW   |  1   |  10   |  01   |  00  |  1   |  1   |  0  | 0XX01 |            |
|        |  SW   |      |       |       |      |      |      |     |       |            |
|        | ADDI  |      |       |       |      |      |      |     |       |            |
|        | ADDIU |      |       |       |      |      |      |     |       |            |
|        | SLTI  |      |       |       |      |      |      |     |       |            |
|        | SLTIU |      |       |       |      |      |      |     |       |            |
|        |  ORI  |      |       |       |      |      |      |     |       |            |
|        |  LUI  |      |       |       |      |      |      |     |       |            |
|        | ANDI  |      |       |       |      |      |      |     |       |            |
|        | XORI  |      |       |       |      |      |      |     |       |            |
|        |  BEQ  |      |       |       |      |      |      |     |       | Z=1 \| Z=0 |
|        |  BNE  |      |       |       |      |      |      |     |       | Z=1 \| Z=0 |
| J-Type |   J   |      |       |       |      |      |      |     |       |            |
|        |  JAL  |      |       |       |      |      |      |     |       |            |
| R-Type |  ADD  |      |       |       |      |      |      |     |       |            |
|        | ADDU  |      |       |       |      |      |      |     |       |            |
|        |  SUB  |      |       |       |      |      |      |     |       |            |
|        |  AND  |      |       |       |      |      |      |     |       |            |
|        |  OR   |      |       |       |      |      |      |     |       |            |
|        |  XOR  |      |       |       |      |      |      |     |       |            |
|        |  NOR  |      |       |       |      |      |      |     |       |            |
|        |  SLT  |      |       |       |      |      |      |     |       |            |
|        | SLTU  |      |       |       |      |      |      |     |       |            |
|        |  SLL  |      |       |       |      |      |      |     |       |            |
|        | SLLV  |      |       |       |      |      |      |     |       |            |
|        |  SRL  |      |       |       |      |      |      |     |       |            |
|        |  SRA  |      |       |       |      |      |      |     |       |            |
|        |  JR   |      |       |       |      |      |      |     |       |            |

## Projete um processador RISC Monociclo

Junte todas as partes do diagrama do caminho de dados para criar um processador RISC single-cycle tal qual discutido em sala de aula. Os c√≥digos Verilog para alguns dos m√≥dulos foram disponibilizados junto com os arquivos de laborat√≥rio. De forma mais espec√≠fica, voc√™ dever√° realizar as tarefas elencadas a seguir.

Por enquanto, vamos escolher um tamanho relativamente pequeno para cada mem√≥ria, por exemplo, 128 posi√ß√µes de mem√≥ria para a mem√≥ria de instru√ß√µes e 64 para a mem√≥ria de dados.

> üíÅ Os endere√ßos produzidos pelo processador para acessar as mem√≥rias ainda continuar√£o sendo de 32 bits, mesmo que sejam utilizados menos bits de endere√ßo. Use os m√≥dulos ROM e RAM do roteiro anterior (`rom.sv` e `ram.sv`}), e observe o seguinte:

- A mem√≥ria de instru√ß√µes ser√° uma ROM, enquanto a mem√≥ria de dados ser√° uma RAM. N√≥s iremos instanciar os m√≥dulos ROM e RAM (sem modificar duas descri√ß√µes Verilog), e fornecer os par√¢metros apropriados, os quais, por sua vez, s√£o definidos no m√≥dulo _top-level_ de teste. (Ver `top.sv`).
- N√≥s vamos enviar todos os 32 bits do contador de programas (`PC`) para fora do processador e conect√°-lo √† mem√≥ria de instru√ß√µes, mas eliminar os √∫ltimos dois bits na interface, de modo que _apenas uma palavra de endere√ßo de 30 bits_ seja realmente enviada para dentro da mem√≥ria de instru√ß√µes. Isso ir√° converter um endere√ßo de byte para um endere√ßo de palavra. (Ver `top.sv`).
- Ambas as mem√≥rias devem retornar uma palavra de 32 bits (`Dbits = 32`). Seus valores iniciais s√£o lidos a partir do `initfile`, o qual corresponde ao nome do arquivo de inicializa√ß√£o da mem√≥ria.

Inicialize as mem√≥rias de instru√ß√µes e dados utilizando o m√©todo apresentado no [Lab 7](../../lab7/spec/spec.md). O arquivo que possui os valores iniciais para a mem√≥ria de instru√ß√µes conter√° uma instru√ß√£o codificada de 32 bits por linha (em hexadecimal). O arquivo que com os valores iniciais para a mem√≥ria de dados tamb√©m ter√° apenas valores de dados de 32 bits a cada linha.

> üíÅ Voc√™ pode criar estes arquivos dentro do pr√≥prio Quartus Prime, ou utilizando seu editor de textos preferido.

- O m√≥dulo do processador, contendo os blocos controlador e _data path_, foi fornecido no arquivo `risc231.sv`. Entenda como ele se espelha no diagrama de blocos apresentado a seguir.

> ‚úÖ Observe que n√£o h√° diferen√ßas entre o projeto do MIPS do livro de Harris e Harris e o que n√≥s estamos desenvolvendo neste roteiro. Entretanto, o nosso processador possui uma vers√£o muito mais sofisticada de ALU. Portanto, n√£o siga de forma irrestrita as informa√ß√µes presentes no livro; ao inv√©s disso, siga os slides de aula e anota√ß√µes dos laborat√≥rios. O caminho de dados deve ser de 32 bits (registradores, ALU, mem√≥ria de dados e mem√≥ria de instru√ß√µes, usam palavras de 32 bits).

- Complete todas as pequenas pe√ßas do caminho de dados, de modo que o projeto se pare√ßa com aquele apresentado na aula, tamb√©m reproduzido a seguir. Pequenos conjuntos de c√≥digo podem ser "aninhados" (no lugar de escritos em m√≥dulos separados), por exemplo, multiplexadores, extensor de sinal, somadores, deslocamento-por-2, etc.

As figuras apresentada na se√ß√£o [A Unidade de Controle](#a-unidade-de-controle) apresentam uma decomposi√ß√£o hier√°rquica do projeto _top-level_. Atente-se que o seu projeto deve seguir **exatamente** essa hierarquia.

![Desenho da arquitetura do processador](./Arch.png)

## Acompanhamento

### Parte 1: Unidade de Controle (entrega: sexta-feira 08 de julho, 2022)

Durante a aula esteja pronto para apresentar para o professor ou monitor:

- O arquivo Verilog: `controller.sv`.
- A simula√ß√£o para a [Unidade de Controle](#a-unidade-de-controle), utilizando o [_test bench_](../sim/tb/controller_tb.sv) fornecido junto com os arquivos de laborat√≥rio.

### Parte 2: Processador RISC231 Monociclo (entrega: sexta-feira 15 de julho, 2022)

ALL of the Verilog files, but skip the ALU and its submodules. Also, the screenshot of the simulation waveforms for the ‚Äúfull‚Äù self-checking tester provided.

- **TODOS** os arquivos Verilog, com exce√ß√£o a ALU e seus sub-m√≥dulos.
- Uma demonstra√ß√£o de funcionamento do seu processador RISC231 utilizando o [testador auto-verific√°vel](../sim/tb/risc231_tb.sv) fornecido junto com os arquivos de laborat√≥rio.

## Agradecimentos

Esse roteiro √© fruto do trabalho coletivo dos professores e monitores de GCET231:

- **18.1:** Caio Fran√ßa dos Santos
- **18.2:** Matheus Rosa Pithon
- **20.2:** Matheus Rosa Pithon
- **21.1:** Matheus Rosa Pithon, √âverton Gomes dos Santos
- **21.2:** √âverton Gomes dos Santos
